
function NewSpikes = BoundaryCondition_NANs_noisy(SpikeTimes, ~, timevec, ~, ~)
% BoundaryCondition_NANs  generates a new set of spike times
% called NewSpikes based on SpikeTimes generated by SimHeterogeniousSpikes.

% NewSpikes is a one-by-Ncols cell array  generated 
% by inserting one spike at the beginning and end of the experiment.
% The inserted spikes act as  a boundary condition used to remove NAN
% values (i.e. clean the data obtained) from the previous time (prevtime)
% and  next time functions (nextime).
% Prevtime and nextime functions are designed to overcome the
% coverage problem encoutered while using the firing rate  to do
% dimensionality reduction

% Usage: NewSpikes = BoundaryCondition_NANs(SpikeTimes)

% Input arguments: 
% SpikeTimes-- one-by-ncols cell array obtained from the
%  SimHeterogeneousSpikes  m-file.
%  Dt -- time step or bin width in [s] 
%  timevec -- length(time)-by-one vector describing
% the time stamps for each row of the data
% length(timevec) = total number of time points.

%Output arguments
% NewSpikes -- one-by-Ncols cell array with an extra spike time inserted
% at the beginning and end of the experiment.
% each cell in NewSpikes has 2 more spike times than generated SpikeTimes

%Default parameters Dt and time are the same as in SimHeterogeneousSpikes.m

%% 
if nargin == 1
   Dt = 0.0015; % time step in [s]
   tstart = 0; % start time of experiment in [s]
   tend = 6.5; % end time of the experiment in [s]
   timevec = tstart:Dt:tend-Dt; 
   %initialize a time vector to index rows of prevtime/nextime;  
end



%% Find the length of the longest spike train to convert 
% all logical arrays into matrices

nrows = zeros(length(SpikeTimes), 1);
for i = 1:length(SpikeTimes)
    nrows(i) = length(SpikeTimes{i});
end
Nrows = max(nrows);


%% Store all the real spike data into a matrix/2D array

SyntheticData = nan(Nrows, length(SpikeTimes));
for i = 1:length(SpikeTimes)
    SyntheticData(1:length(SpikeTimes{i}), i) =  SpikeTimes{i}; 
end



%%  Limit spiking to time on and off track

Ncols = size(SyntheticData, 2); %number of neurons or columns in the data

idx = zeros(size(SyntheticData,1), Ncols); %matrix for prevtime logicals
idx2 = zeros(size(SyntheticData,1), Ncols); %matrix for next time logicals
prevtime = zeros(length(timevec), Ncols); %initialize the prevtime vector
nextime = nan(length(timevec), Ncols);%initialize the nextime vector
tmp = zeros(length(timevec), Ncols); % store indices of idx in tmp matrix
tmp2 = nan(length(timevec), Ncols); % store indices of idx2 in tmp2 matrix
NewSpikes = cell(1,Ncols);


%%


for i = 1:length(timevec)
  for j = 1:Ncols
  
      % look for elements </> time respectively
      
        idx(:,j) =  SyntheticData(:,j)  <  timevec(i);
        idx2(:,j) =  SyntheticData(:,j) >  timevec(i);
    
    if (sum(idx(:,j))~=0)  % exclude empty arrays

   %save the indices corresponding to non-empty arrays from from idx into tmp
   count = nnz(~isnan(SyntheticData(:,j))); %count the number of non_NAN values in each column
    tmp =   max(SyntheticData(find(idx(1:count, j)), j)); %choose the maximum number satisfying the idx condition
  
   % compute prevtime 
   prevtime(i,j) = tmp-timevec(i);
 
        else
          prevtime(i,j) = nan;
    end
    
    %repeat the same exact proceedure above for nextime
    if (sum(idx2(:,j))~=0)  

   count2 = nnz(~isnan(SyntheticData(:,j))); 
   %count the number of non_NAN values in each column
  tmp2 =   min(SyntheticData(find(idx2(1:count2, j)), j)); 
  %choose the minimum number satisfying the idx2 condition
  
  %compute nextime
  nextime(i,j) = tmp2-timevec(i);
 
        else
          nextime(i,j) = nan;
    end
    
    
    
  end
end


%% Compute the mean of PrevTime and NextTime along the time dimension
% and add it to the spiketime vector cell wise.

prevtime(isnan(prevtime)) = []; %delete all nan values from PrevTime---indeed the sizes change!
nextime(isnan(nextime)) = []; %delete all nan values from NextTime---indeed the sizes change!
% before i was using the inbuilt function omitnan which is even too slow.

mean_PrevTime = mean(prevtime, 2);  %compute mean of PrevTime without nans
mean_NextTime = mean(nextime, 2);  %compute mean of NextTime without nans

% mean_PrevTime
% mean_NextTime

% Now add a spike before and after spiketime into each individual cell
% do this by adding SpikeTimes - mean(PrevTime) at the beginning of each
% cell array and then statetime(end) + mean(NextTime) at the end of each cell
% array

%%
for j = 1:Ncols
    NewSpikes{j} = [timevec(1)+mean_PrevTime  SpikeTimes{j}  timevec(end)+mean_NextTime]; 
    %insert a spike at the beginning to remove nans from prevtime.
end









